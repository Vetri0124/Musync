{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\user\\\\Desktop\\\\Musync\\\\frontend\\\\src\\\\context\\\\AudioContext.js\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState } from 'react';\nimport axios from 'axios';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst AudioContext = /*#__PURE__*/createContext();\nconst AudioProvider = ({\n  children\n}) => {\n  _s();\n  const [recording, setRecording] = useState(false);\n  const [audioBlob, setAudioBlob] = useState(null);\n  const [result, setResult] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const startRecording = async () => {\n    console.log('Attempting to start recording...');\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      const mediaRecorder = new MediaRecorder(stream);\n      const audioChunks = [];\n      mediaRecorder.ondataavailable = e => {\n        audioChunks.push(e.data);\n      };\n      mediaRecorder.onstop = async () => {\n        console.log('Recording stopped. Creating audio blob...');\n        const audioBlob = new Blob(audioChunks, {\n          type: 'audio/wav'\n        });\n        setAudioBlob(audioBlob);\n        // Stop all tracks in the stream to release microphone\n        stream.getTracks().forEach(track => track.stop());\n      };\n      mediaRecorder.start();\n      setRecording(true);\n      setError(null); // Clear any previous errors\n      setResult(null); // Clear previous results\n      console.log('Recording started.');\n      return mediaRecorder;\n    } catch (err) {\n      console.error('Error accessing microphone:', err);\n      if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {\n        setError('Microphone access denied. Please allow microphone permissions in your browser settings.');\n      } else if (err.name === 'NotFoundError') {\n        setError('No microphone found. Please ensure a microphone is connected and working.');\n      } else {\n        setError('Failed to start recording. Please try again.');\n      }\n      setRecording(false); // Ensure recording state is false if it fails to start\n      return null; // Return null if recorder couldn't be created\n    }\n  };\n  const stopRecording = mediaRecorder => {\n    if (mediaRecorder && mediaRecorder.state !== 'inactive') {\n      console.log('Stopping media recorder...');\n      mediaRecorder.stop();\n      setRecording(false);\n    }\n  };\n  const recognizeSong = async () => {\n    if (!audioBlob) {\n      setError('No audio to recognize. Please record first.');\n      return;\n    }\n    setLoading(true);\n    setError(null);\n    setResult(null); // Clear previous results before new recognition\n\n    try {\n      console.log('Sending audio blob to backend for recognition...');\n      const formData = new FormData();\n      formData.append('audio', audioBlob, 'recording.wav');\n\n      // --- CRITICAL CORRECTION: Use full URL for backend API ---\n      const res = await axios.post('http://localhost:5000/api/recognize', formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data',\n          Authorization: `Bearer ${localStorage.getItem('token')}` // Ensure token is valid if authentication is required\n        }\n      });\n      console.log('Recognition successful:', res.data);\n      setResult(res.data);\n    } catch (err) {\n      var _err$response;\n      console.error('Recognition failed:', ((_err$response = err.response) === null || _err$response === void 0 ? void 0 : _err$response.data) || err.message);\n      let errorMessage = 'Song recognition failed. Please try again.';\n      if (err.response) {\n        if (err.response.status === 401) {\n          errorMessage = 'Authentication required. Please log in.';\n        } else if (err.response.data && err.response.data.message) {\n          errorMessage = err.response.data.message;\n        } else if (err.response.statusText) {\n          errorMessage = `Error: ${err.response.status} ${err.response.statusText}`;\n        }\n      } else if (err.request) {\n        errorMessage = 'Network error: Could not reach the server. Is your backend running?';\n      }\n      setError(errorMessage);\n    } finally {\n      setLoading(false);\n    }\n  };\n  const reset = () => {\n    console.log('Resetting audio context state...');\n    setAudioBlob(null);\n    setResult(null);\n    setError(null);\n    setRecording(false); // Ensure recording state is reset\n    setLoading(false); // Ensure loading state is reset\n  };\n  return /*#__PURE__*/_jsxDEV(AudioContext.Provider, {\n    value: {\n      recording,\n      audioBlob,\n      result,\n      loading,\n      error,\n      startRecording,\n      stopRecording,\n      recognizeSong,\n      reset\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 116,\n    columnNumber: 5\n  }, this);\n};\n_s(AudioProvider, \"+ipqIAooPE+qvUuM/uKFI88n8r4=\");\n_c = AudioProvider;\nexport { AudioContext, AudioProvider };\nvar _c;\n$RefreshReg$(_c, \"AudioProvider\");","map":{"version":3,"names":["React","createContext","useState","axios","jsxDEV","_jsxDEV","AudioContext","AudioProvider","children","_s","recording","setRecording","audioBlob","setAudioBlob","result","setResult","loading","setLoading","error","setError","startRecording","console","log","stream","navigator","mediaDevices","getUserMedia","audio","mediaRecorder","MediaRecorder","audioChunks","ondataavailable","e","push","data","onstop","Blob","type","getTracks","forEach","track","stop","start","err","name","stopRecording","state","recognizeSong","formData","FormData","append","res","post","headers","Authorization","localStorage","getItem","_err$response","response","message","errorMessage","status","statusText","request","reset","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/user/Desktop/Musync/frontend/src/context/AudioContext.js"],"sourcesContent":["import React, { createContext, useState } from 'react';\r\nimport axios from 'axios';\r\n\r\nconst AudioContext = createContext();\r\n\r\nconst AudioProvider = ({ children }) => {\r\n  const [recording, setRecording] = useState(false);\r\n  const [audioBlob, setAudioBlob] = useState(null);\r\n  const [result, setResult] = useState(null);\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n\r\n  const startRecording = async () => {\r\n    console.log('Attempting to start recording...');\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\r\n      const mediaRecorder = new MediaRecorder(stream);\r\n      const audioChunks = [];\r\n\r\n      mediaRecorder.ondataavailable = (e) => {\r\n        audioChunks.push(e.data);\r\n      };\r\n\r\n      mediaRecorder.onstop = async () => {\r\n        console.log('Recording stopped. Creating audio blob...');\r\n        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });\r\n        setAudioBlob(audioBlob);\r\n        // Stop all tracks in the stream to release microphone\r\n        stream.getTracks().forEach(track => track.stop());\r\n      };\r\n\r\n      mediaRecorder.start();\r\n      setRecording(true);\r\n      setError(null); // Clear any previous errors\r\n      setResult(null); // Clear previous results\r\n      console.log('Recording started.');\r\n\r\n      return mediaRecorder;\r\n    } catch (err) {\r\n      console.error('Error accessing microphone:', err);\r\n      if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {\r\n        setError('Microphone access denied. Please allow microphone permissions in your browser settings.');\r\n      } else if (err.name === 'NotFoundError') {\r\n        setError('No microphone found. Please ensure a microphone is connected and working.');\r\n      } else {\r\n        setError('Failed to start recording. Please try again.');\r\n      }\r\n      setRecording(false); // Ensure recording state is false if it fails to start\r\n      return null; // Return null if recorder couldn't be created\r\n    }\r\n  };\r\n\r\n  const stopRecording = (mediaRecorder) => {\r\n    if (mediaRecorder && mediaRecorder.state !== 'inactive') {\r\n      console.log('Stopping media recorder...');\r\n      mediaRecorder.stop();\r\n      setRecording(false);\r\n    }\r\n  };\r\n\r\n  const recognizeSong = async () => {\r\n    if (!audioBlob) {\r\n      setError('No audio to recognize. Please record first.');\r\n      return;\r\n    }\r\n\r\n    setLoading(true);\r\n    setError(null);\r\n    setResult(null); // Clear previous results before new recognition\r\n\r\n    try {\r\n      console.log('Sending audio blob to backend for recognition...');\r\n      const formData = new FormData();\r\n      formData.append('audio', audioBlob, 'recording.wav');\r\n\r\n      // --- CRITICAL CORRECTION: Use full URL for backend API ---\r\n      const res = await axios.post('http://localhost:5000/api/recognize', formData, {\r\n        headers: {\r\n          'Content-Type': 'multipart/form-data',\r\n          Authorization: `Bearer ${localStorage.getItem('token')}` // Ensure token is valid if authentication is required\r\n        }\r\n      });\r\n\r\n      console.log('Recognition successful:', res.data);\r\n      setResult(res.data);\r\n    } catch (err) {\r\n      console.error('Recognition failed:', err.response?.data || err.message);\r\n      let errorMessage = 'Song recognition failed. Please try again.';\r\n      if (err.response) {\r\n        if (err.response.status === 401) {\r\n          errorMessage = 'Authentication required. Please log in.';\r\n        } else if (err.response.data && err.response.data.message) {\r\n          errorMessage = err.response.data.message;\r\n        } else if (err.response.statusText) {\r\n          errorMessage = `Error: ${err.response.status} ${err.response.statusText}`;\r\n        }\r\n      } else if (err.request) {\r\n        errorMessage = 'Network error: Could not reach the server. Is your backend running?';\r\n      }\r\n      setError(errorMessage);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const reset = () => {\r\n    console.log('Resetting audio context state...');\r\n    setAudioBlob(null);\r\n    setResult(null);\r\n    setError(null);\r\n    setRecording(false); // Ensure recording state is reset\r\n    setLoading(false); // Ensure loading state is reset\r\n  };\r\n\r\n  return (\r\n    <AudioContext.Provider value={{\r\n      recording,\r\n      audioBlob,\r\n      result,\r\n      loading,\r\n      error,\r\n      startRecording,\r\n      stopRecording,\r\n      recognizeSong,\r\n      reset\r\n    }}>\r\n      {children}\r\n    </AudioContext.Provider>\r\n  );\r\n};\r\n\r\nexport { AudioContext, AudioProvider };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}